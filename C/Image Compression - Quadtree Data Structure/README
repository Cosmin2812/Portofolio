Explicatie solutie:
    -- Task 1: Se citesc datele din fisierul de intrare intr-o variabila de tip imag.
    In variabila de tip imag sunt stocate tipul imaginii (P6 in cazul nostru), dimensiunea maxima a pixelilor (255) si imaginea intr-o matrice de tipul pixel. Tipul pixel retine valorile RGB pentru un singur pixel.
    Dupa introducerea datelor in variabila, este creat arborele cuaternar. Functia de creare incepe de la imaginea mare, creeaza nodul radacina, calculeaza scorul de similaritate, iar daca acesta este mai mare decat valoarea de prag, atunci se imparte in patru si se efectueaza acelasi lucru pana cand se ajunge la valori mai mici decat pragul. In acest caz sunt salvate in frunze valorile RGB calculate.
    Apoi, se calculeaza numarul de niveluri din arbore printr-o functie recursiva si numarul de blocuri din imagine pentru care scorul similaritatii este mai mic sau egal decat factorul furnizat este de fapt, numarul de frunze, care se obtine tot printr-o functie recursiva. Pentru dimensiunea blocului cel mai mare care a ramas nedivizat, se afla mai intai nivelul minim pe care exista o frunza, iar apoi se imparte dimensiunea imaginii la numarul nivelului inmultita cu 4, obtinand astfel dimensiunea blocului dorita.

    -- Task 2: Avand arborele cuaternar, pentru a introduce datele conform enuntului trebuie sa il parcurgem prin Breadth First Search. Algoritmul se bazeaza pe folosirea unei cozi pentru a parcurgere arborele. Se incepe de la radacina, se scrie 1 urmat de valorile RGB, daca aceasta nu are fii, sau 0 daca aceasta are. In cazul lui 0, fii sunt adaugati in coada. Se extrage un nod din coada, se aplica acelasi procedeu pentru nodul extras si tot asa pana cand coada va fi goala.

    -- Task 3: Avand fisierul de compresie, cream arborele corespunzator imaginii compresate. Algoritmul este asemanator cu cel de la Task-ul 2. Se creeaza primul nod si se citeste valoarea din fisier. Daca valoarea este 1, atunci urmatoarele 3 valori sunt valorile RGB care se vor introduce in nod. Daca valoarea este 0, se creeaza fii nodului si se introduc in coada. Se extrage un nod din coada si se aplica acelasi procedeu pana cand se termina citirea (sau pana cand coada este goala, momentele vor coincide). 
    Algoritmul de refacerea a imaginii (intr-o variabila de tip imag) se bazeaza pe ideea de la task-ul 1. Stiind dimensiunea imaginii (din fisierul compresat), pornim de la o matrice patratica cu latura de dimensiunea respectiva.
    Aceasta se imparte in 4, apoi sferturile se impart si ele in 4, pana cand se ajunge la frunzele arborelui de compresie (arborele este parcurs Depth First Search in paralel). Ajuns la frunza, se vor introduce valorile RGB pentru sectorul corepsunzator nodului (stanga sus, dreapta sus, stanga jos, dreapta jos). In acest fel, recursiv, se va completa matricea de pixeli.
    In final, datele din variabila de tip imag sunt scrise in format binar in fisier-ul de output, conform formatului PPM al fisierului.

    -- Dezalocare: Dupa efectuarea task-urilor se dezaloca toata memoria care a fost alocata (arborele, zona corespunzatoare a struct-ului imag si toate datele care au fost alocate dinamic in interiorul acestora)